#include <iostream>
using namespace std;

// 取模運算 (Modulo Operation)
// a mod b = r
// [探討]：數學上和程式語言上的差異
//  --> a 為負數探討
// 如果 a 為負數，不同程式語言，將會不同

int main() {
    // C++ 取模 (mod) 與數學上不同
    // 數學上，取模運算，餘數為非負整數
    // 數學上 -7 mod 3 = 2
    // C++ 上：
    cout << -7 % 3 << endl; // -1

    // 為了讓 C++ 與 數學結果相同
    // 公式 (a % b + b) % b

    int a = -7;
    int b = 3;
    cout << (a % b + b) % b << endl; // 2
}

/*

C# 和 C++ 之所以將取模的結果設計成「與被除數的符號一致」，
是出於一些設計上的考量，主要與 語言一致性 和 整數除法的行為 有關。

1. 與整數除法保持一致
在 C# 和 C++ 中，整數除法 
𝑎 / 𝑏 會向零（truncate toward zero）取整。這種設計對應於取模運算中餘數的符號必須與被除數 a 一致，
才能滿足基本的數學關係：

                   a=b⋅q+r

    - q 是商，等於 𝑎/𝑏（向零取整）。
    - r 是餘數，且滿足：
                  r=a−b⋅q
    例子：負數的整數除法
    假設 a = -7, b = 3:
    - 整數除法 a / b = -2 (向零取整)。
    - 餘數 r = a - b*q =  -7 - (3 * -2) = -1
    因此，取模的結果必須是 -1 ，否則無法滿足上述公式

2. 提升程式語言的一致性
    取模的符號與被除數一致，對程式設計者來說更直觀，因為：
    1. 在迴圈計算、索引操作等情境中，保持一致的符號規則更容易理解。
    2. 若符號隨除數變化，會導致一些令人困惑的行為。
    範例：一致性對比
    假設 a = -7, b = 3:
    若符號與 b 一致(數學規則)：-7 mod 3 = 2
    若符號與 a 一致(C++規則)：-7 % 3 = -1

3. 便於底層實現
    在 C++ 和 C# 的底層實現中，取模運算的設計直接與處理器的除法指令相關。
    大部分硬體架構都使用「商向零取整」的方式實現整數除法，
    因此設計取模運算時，直接保持與整數除法一致的符號處理是更簡單、更高效的選擇。

4. 向下相容性
    C 和 C++ 是現代編程語言的基石，其取模規則早在 C 語言設計時就已確定
    （取模結果的符號與被除數一致）。C# 繼承了這一規則，旨在與 C++ 和底層硬體行為保持一致。

Ｑ：為什麼與數學不同？
    - 數學中的取模運算更多是從「週期性」的角度設計的，因此餘數通常是非負的，
    適合用於時鐘、環狀計算等場景。
    - 程式語言中的取模更關注「整數除法的結果一致性」，因此選擇了這種符號規則。

結論:
    為什麼 C# 和 C++ 與數學不同？
    - 保持與整數除法一致性。
    - 提升低層運算效率，減少硬體指令開銷。
    - 繼承 C 語言的設計，確保向下相容性。
    - 如果需要數學行為，可以用公式 (a % b + b) % b
*/